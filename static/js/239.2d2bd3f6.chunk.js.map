{"version":3,"file":"static/js/239.2d2bd3f6.chunk.js","mappings":"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","sources":["utils/performance.ts","components/ParticleBackground.tsx"],"sourcesContent":["/**\n * Performance configuration and utilities for WAT.ai website\n * Centralizes performance settings to maintain optimal user experience\n * across different devices and network conditions\n */\nexport const PERFORMANCE_CONFIG = {\n  // Intersection Observer settings for lazy loading\n  LAZY_LOADING_THRESHOLD: 0.1, // Trigger when 10% visible\n  LAZY_LOADING_ROOT_MARGIN: '50px', // Pre-load 50px before viewport\n  \n  // Particle animation limits based on device capability\n  PARTICLE_COUNT_MOBILE: 100, // Increased for testing visibility\n  PARTICLE_COUNT_DESKTOP: 200, // Increased for testing visibility\n  PARTICLE_LINK_RADIUS: 250, // Increased for better connectivity\n  \n  // Vis.js network graph optimization\n  PHYSICS_ITERATIONS: 100, // Faster stabilization vs visual quality tradeoff\n  STABILIZATION_ENABLED: true, // Allow automatic layout optimization\n  \n  // Webpack bundle optimization\n  CHUNK_SIZE_WARNING_LIMIT: 500000, // 500KB chunks for optimal loading\n  \n  // Cache management\n  CACHE_DURATION: 3600000, // 1 hour for static assets\n};\n\n/**\n * Development-only performance monitoring utility\n * Measures execution time of functions to identify bottlenecks\n */\nexport const trackPerformance = (name: string, fn: () => void) => {\n  if (process.env.NODE_ENV === 'development') {\n    const start = performance.now();\n    fn();\n    const end = performance.now();\n    console.log(`${name} took ${end - start} milliseconds`);\n  } else {\n    fn();\n  }\n};\n\n/**\n * Debounce utility to limit function execution frequency\n * Prevents excessive API calls or expensive operations during rapid user input\n */\nexport const debounce = <T extends (...args: any[]) => any>(\n  func: T,\n  delay: number\n): ((...args: Parameters<T>) => void) => {\n  let timeoutId: NodeJS.Timeout;\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(null, args), delay);\n  };\n};\n\n// Throttle function for scroll/resize events\nexport const throttle = <T extends (...args: any[]) => any>(\n  func: T,\n  delay: number\n): ((...args: Parameters<T>) => void) => {\n  let inThrottle = false;\n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      func.apply(null, args);\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), delay);\n    }\n  };\n};\n","// Animated particle background for visual effect.\n// Edit options for color, speed, or density. Used on landing/team pages.\nimport React, { useEffect, useRef } from \"react\";\nimport { PERFORMANCE_CONFIG } from \"../utils/performance\";\n\nconst ParticleBackground: React.FC = () => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    let w: number,\n      h: number,\n      canvas: HTMLCanvasElement,\n      ctx: CanvasRenderingContext2D | null;\n    let particles: Particle[] = [];\n\n    const options = {\n      particleColor: \"rgba(150, 150, 150, 0.3)\",\n      lineColor: \"rgba(255, 206, 26, 0.4)\",\n      particleAmount: 0, // Dynamically calculated based on screen size\n      defaultRadius: 5,\n      variantRadius: 3,\n      defaultSpeed: 0.2,\n      variantSpeed: 0.2,\n      linkRadius: PERFORMANCE_CONFIG.PARTICLE_LINK_RADIUS,\n    };\n\n    const rgb = options.lineColor.match(/\\d+/g) as string[];\n\n    /**\n     * Initialize canvas and start particle animation\n     * Uses delayed start to avoid blocking initial page render\n     */\n    const init = () => {\n      canvas = canvasRef.current!;\n      if (!canvas) {\n        return;\n      }\n      \n      ctx = canvas.getContext(\"2d\");\n      if (!ctx) {\n        return;\n      }\n      \n      resizeReset();\n      \n      // Start animation immediately\n      startAnimation();\n    };\n\n    /**\n     * Handle canvas resize and particle redistribution\n     * Maintains particle density while preventing performance degradation\n     * Scales existing particles to new dimensions to avoid jarring transitions\n     */\n    const resizeReset = () => {\n      const oldW = w;\n      const oldH = h;\n      \n      w = canvas.width = window.innerWidth;\n      h = canvas.height = window.innerHeight; // Cover full document height\n      canvas.style.width = `${w}px`;\n      canvas.style.height = `${h}px`;\n\n      // Scale existing particles to new dimensions\n      if (particles.length > 0 && oldW && oldH) {\n        const scaleX = w / oldW;\n        const scaleY = h / oldH;\n        \n        particles.forEach(particle => {\n          particle.x *= scaleX;\n          particle.y *= scaleY;\n          \n          // Keep particles within bounds\n          particle.x = Math.min(Math.max(particle.x, 0), w);\n          particle.y = Math.min(Math.max(particle.y, 0), h);\n        });\n      }\n\n      // Optimize particle count based on device capability\n      const isMobile = window.innerWidth < 768;\n      const maxParticles = isMobile \n        ? PERFORMANCE_CONFIG.PARTICLE_COUNT_MOBILE \n        : PERFORMANCE_CONFIG.PARTICLE_COUNT_DESKTOP;\n      const newParticleAmount = Math.min(Math.floor(w / 25), maxParticles);\n      \n      // Handle particle count changes without losing existing particles\n      if (particles.length === 0) {\n        // First initialization\n        options.particleAmount = newParticleAmount;\n        initialiseElements();\n      } else if (newParticleAmount > particles.length) {\n        // Add new particles to existing array\n        const particlesToAdd = newParticleAmount - particles.length;\n        for (let i = 0; i < particlesToAdd; i++) {\n          particles.push(new Particle());\n        }\n        options.particleAmount = newParticleAmount;\n      } else if (newParticleAmount < particles.length) {\n        // Remove excess particles\n        particles = particles.slice(0, newParticleAmount);\n        options.particleAmount = newParticleAmount;\n      }\n      // If newParticleAmount === particles.length, do nothing\n    };\n\n    const initialiseElements = () => {\n      particles = [];\n      for (let i = 0; i < options.particleAmount; i++) {\n        particles.push(new Particle());\n      }\n    };\n\n    let animationId: number;\n    let lastTime = 0;\n    const targetFPS = 60;\n    const frameInterval = 1000 / targetFPS;\n\n    const startAnimation = () => {\n      animationId = requestAnimationFrame(animationLoop);\n    };\n\n    const animationLoop = (currentTime: number) => {\n      if (currentTime - lastTime >= frameInterval) {\n        if (ctx) {\n          ctx.clearRect(0, 0, w, h);\n          drawScene();\n        }\n        lastTime = currentTime;\n      }\n      animationId = requestAnimationFrame(animationLoop);\n    };\n\n    const drawScene = () => {\n      drawLine();\n      drawParticle();\n    };\n\n    const drawParticle = () => {\n      particles.forEach((particle) => {\n        particle.update();\n        particle.draw();\n      });\n    };\n\n    const drawLine = () => {\n      particles.forEach((particle) => {\n        linkPoints(particle, particles);\n      });\n    };\n\n    const linkPoints = (point: Particle, hubs: Particle[]) => {\n      // Optimize by only checking nearby particles\n      hubs.forEach((hub) => {\n        if (point === hub) return; // Skip self\n        \n        const dx = point.x - hub.x;\n        const dy = point.y - hub.y;\n        \n        // Quick distance check before expensive sqrt\n        const distanceSquared = dx * dx + dy * dy;\n        const linkRadiusSquared = options.linkRadius * options.linkRadius;\n        \n        if (distanceSquared < linkRadiusSquared) {\n          const distance = Math.sqrt(distanceSquared);\n          const opacity = (1 - distance / options.linkRadius) * 0.6; // Reduced opacity\n          \n          if (ctx) {\n            ctx.lineWidth = 0.3; // Thinner lines for better performance\n            ctx.strokeStyle = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${opacity})`;\n            ctx.beginPath();\n            ctx.moveTo(point.x, point.y);\n            ctx.lineTo(hub.x, hub.y);\n            ctx.stroke();\n          }\n        }\n      });\n    };\n\n    class Particle {\n      x: number;\n      y: number;\n      color: string;\n      radius: number;\n      speed: number;\n      directionAngle: number;\n      vector: { x: number; y: number };\n\n      constructor() {\n        this.x = Math.random() * w;\n        this.y = Math.random() * h;\n        this.color = options.particleColor;\n        this.radius =\n          options.defaultRadius + Math.random() * options.variantRadius;\n        this.speed =\n          options.defaultSpeed + Math.random() * options.variantSpeed;\n        this.directionAngle = Math.floor(Math.random() * 360);\n        this.vector = {\n          x: Math.cos(this.directionAngle) * this.speed,\n          y: Math.sin(this.directionAngle) * this.speed,\n        };\n      }\n\n      update() {\n        this.border();\n        this.x += this.vector.x;\n        this.y += this.vector.y;\n      }\n\n      border() {\n        if (this.x >= w || this.x <= 0) {\n          this.vector.x *= -1;\n        }\n        if (this.y >= h || this.y <= 0) {\n          this.vector.y *= -1;\n        }\n        if (this.x > w) this.x = w;\n        if (this.y > h) this.y = h;\n        if (this.x < 0) this.x = 0;\n        if (this.y < 0) this.y = 0;\n      }\n\n      draw() {\n        if (ctx) {\n          ctx.fillStyle = this.color;\n          ctx.beginPath();\n          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n    }\n\n    window.addEventListener(\"resize\", resizeReset);\n    init();\n\n    return () => {\n      window.removeEventListener(\"resize\", resizeReset);\n      if (animationId) {\n        cancelAnimationFrame(animationId);\n      }\n    };\n  }, []);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      style={{\n        position: \"fixed\",\n        top: \"0px\",\n        left: \"0px\",\n        width: \"100%\",\n        height: \"100%\",\n        zIndex: 0,\n        display: \"block\",\n        pointerEvents: \"none\",\n      }}\n    />\n  );\n};\n\nexport default ParticleBackground;\n"],"names":["PERFORMANCE_CONFIG","ParticleBackground","canvasRef","useRef","useEffect","w","h","canvas","ctx","particles","options","particleColor","lineColor","particleAmount","defaultRadius","variantRadius","defaultSpeed","variantSpeed","linkRadius","rgb","match","resizeReset","oldW","oldH","width","window","innerWidth","height","innerHeight","style","concat","length","scaleX","scaleY","forEach","particle","x","y","Math","min","max","maxParticles","newParticleAmount","floor","initialiseElements","particlesToAdd","i","push","Particle","slice","animationId","lastTime","frameInterval","startAnimation","requestAnimationFrame","animationLoop","currentTime","clearRect","drawScene","drawLine","drawParticle","update","draw","linkPoints","point","hubs","hub","dx","dy","distanceSquared","opacity","sqrt","lineWidth","strokeStyle","beginPath","moveTo","lineTo","stroke","constructor","color","radius","speed","directionAngle","vector","this","random","cos","sin","border","fillStyle","arc","PI","fill","addEventListener","current","getContext","removeEventListener","cancelAnimationFrame","_jsx","ref","position","top","left","zIndex","display","pointerEvents"],"sourceRoot":""}